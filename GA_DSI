prework:
feature engineering: Create columns derived from our data

What does a compelling data-driven presentation look like?
-Summarizing your findings.
-Labeling all plots and visualizations.
-Restating your hypothesis and initial assumptions.
-Describing your data and process.
-Explaining your model’s strengths and limitations.
-Providing an appropriate degree of disclosure for your audience (especially when dealing with proprietary data or sensitive user information).

range(x): 0 to x, not inclusive of x
range(a,b,c): a=start,b=stop,c=step

One way of vectorizing your data is called label encoding — assigning numerical values to each attribute.
Another common technique for vectorizing categorical data is called one-hot encoding (sometimes abbreviated as “OHE”).

The n points in an n-dimensional vector, x, each refer to the offset from nn orthogonal axes. 
We can define the magnitude of the vector x to be:∣∣x∣∣ = sqrt {(x_1^2 + x_2^2 + ... + x_n^2).
The magnitude is the square root of the sum of each component squared.

Normalizing a vector means that we’re mapping the vector to a point on the unit.
v^ = (v1,...,vn)/∣v∣=( v1/∣v∣,..., vn/∣v∣)

matrices are written as nested lists, just as you’d write them in NumPy. So, the first nested list is the first row.
 
This is a new way of thinking about matrices. Instead of just storing data points, we’re now using matrices to store systems of equations.A unit circle in three dimensions is a unit sphere. In higher dimensions, it’s a unit hypersphere.

to add: np.array
dot product: np.dot(x,y)

A set is a collection of unordered, unique elements.There are two approaches to use when creating a set:
-Curly braces
-Using the built-in set() function with an iterable as an argument
Taking advantage of sets means your program runs faster and uses less memory. If you don't have duplicates and you don't need order, use a set.

there are three types of probability:
Marginal probability: The likelihood of a single event occurring, independent of any other events happening before or after it.
Joint probability: The likelihood of two independent events happening together, where the occurrence of one does not affect the occurrence of the other.
Conditional probability: The likelihood of two events happening together, where the occurrence of one affects the occurrence of the other.

the equals sign (or, in Python speak, the assignment operator) assigns the value to each variable.

data types: numbers,none,boolean,strings,lists,tuples,sets,dictionaries

Lists are:
Ordered: Their elements have a particular order that will never change.
Heterogeneous: Different data types can be stored for each element in the list. For example, ['cat', 10, 0.4].
Mutable: When you alter a list, you don't create a new element — the original element is just modified.

pop() removes an element from a list. You can provide it the specific index to remove, or else it will default to removing the last element from the list.
append() adds an item to the end of a list.

tuples are similar to lists in that you can store multiple values. However, there's one huge difference:
Tuples are immutable — you can't alter a tuple element once it's been created.
Additionally, because tuples have fixed sizes (determined when they're assigned initial values), they're more memory-efficient than a list, which needs additional memory allocated to it.
To define a new tuple, use parentheses instead of brackets
Tuples are used for information that won't change: the days of the week

To check whether an element is in a set, we use the in operator.
Eg 'Riyadh' in my_places_traveled 
True

As with sets, a dictionary is defined using curly braces. 
However, each element of a dictionary consists of a key, followed by a colon, then by a value.

To create an empty set, use the built-in set() function (e.g., untasty_fruits = set()). Why? Because in Python, curly braces are used for both sets and dictionaries. Empty braces {} indicate an empty dictionary.

len() only count unique values in sets. list everything counted

One basic type of error is a NameError. A NameError is thrown when the variable that’s referred to doesn’t exist in the namespace.

A SyntaxError (quite possibly the most common type of error) indicates that something you wrote doesn’t follow the proper Python syntax.
A SyntaxError means we’ve mistyped something somewhere and, as a result, Python doesn’t understand what we’re trying to do.
Python even tries to help us troubleshoot! An arrow (^) under the offending section of code indicates where the problem occurred.

A TypeError occurs when we try to manipulate data types in a way that Python does not permit, such as adding a string and an integer or trying to get the length of an integer.

The try command lets you test a block of code for errors.

The except keyword can help you catch any exception that could occur in a try statement.

The GitHub Flow:
The workflow for contributing to an open-source product or your dev team’s project comprises the following steps:
1)Forking
2)Cloning
3)Editing
4)Adding/committing
5)Pushing
6)Submitting a pull request

Step 1: Forking
To add a copy of someone else’s GitHub repository to your GitHub account, fork it by clicking the Fork button in the upper right-hand corner.
This forked repository is not perfectly identical, but it includes all of the same source files, issues, and commit history.

Step 2: Cloning
To make a local copy of a fork, you’ll clone the repository. This will save the code on your machine so you can edit it.
To do so, open your terminal, navigate to where you’d like to store the repository, then type:
git clone https://url-to-clone
You can find the URL to clone by clicking the green button that says “Clone or download.”
Hint: If you’re following along in Git Bash on Windows, the commands to copy and paste a repository are a little different than the default Windows copy/paste commands. Use control + insert to copy and shift + insert to paste.

Step 3: Editing
You’ll do this using a text editor of your choice. Atom and Sublime are some of the most popular.

Step 4: Adding and Committing
Remember, you’re editing the code on your local copy of the repository. We know that any time we do this, we need to use some very important Git commands so that our local copy is protected if we goof up.
$ git add <your-file-name>
$ git commit -m "message"

Step 5: Pushing
Once you’ve committed these changes, your local repository will differ from your remote repository.
To update your remote repository on GitHub, you have to push those changes using the git push origin master command.

You don't need to worry about the origin and master part just yet. However, if you’re curious, here’s a brief overview:
origin is a shortcut for the URL of your default remote repository (in this case, the repository on GitHub). You can have many remotes if you want, but we’re only going to work with one for now.
master refers to the branch on your remote repository where you are currently adding your changes. Again, for now, we’re just going to be working on the master branch.

Step 6: Submitting a Pull Request
At this point, your local and remote repositories contain the changes you’ve made. If you want to share these changes with the original repository owner, you can submit a pull request.
A pull request effectively says, “Hello, maintainer of Project X. I made some changes here in my forked copy, and I think they’re good ones. You should add them to your repository.”
Pull requests are a GitHub feature, so you’ll need to head back to the browser to submit them.

Assembly is a sequence of instructions written by a programmer, which is then translated by an assembler into the 1s and 0s that computer hardware can recognize.
Developers and programmers can choose from thousands of programming languages that are easier to read and write than assembly languages, including C++, Java, JavaScript, and Python.

All computers speak to the world through an API, an application programming interface.
In the case of the earliest computers, such as the difference engine, the API was a hand crank and the output was achieved through a series of mechanical wheels on the device that the operator would need to interpret.
Modern computers and most programs communicate with the world through a graphical user interface (GUI, pronounced like “gooey”). You as the user input information using a keyboard and mouse, and the result is displayed on the screen. A GUI is an API that’s intended to be used by human beings.
By contrast, the command line interface (CLI) — also called a terminal — is a software application that interfaces with program APIs more directly, using text instead of graphics.

command + tab on Mac and alt + tab on Windows. This will allow you to quickly toggle between the browser on which you’re viewing this lesson and your CLI.

On a Mac, press command + space to bring up the spotlight search. Type in “terminal” and press return.On Windows, go to the start menu, type “Git Bash” into the search, then open the application.

Git: programme for version control

In programming speak, all folders are called directories. A directory within another directory is called a subdirectory. A directory that contains a subdirectory is called a parent directory.
By default, our terminal starts in what is referred to as the home directory.
For Mac, it is /Users/yourname/.
For Windows, it is c:\users\yourname.
For Linux, it is /home/yourname.

The prompt is the $ that automatically shows up at the end of the first line. It’s the command line equivalent of “standby” and indicates that the terminal is ready to accept your command.
The cursor follows the prompt. This is where the text you type will appear, just like in any other setting in which you’ve seen a cursor.
The username of the person logged in precedes the prompt.

The pwd command stands for “print working directory.” 
To find out which files are in our current directory, type ls, short for “list.”
To change directories, we’ll use cd — “change directory” — plus the name of the directory to which we want to change. Simple enough!
Eg cd Documents

Operating systems and installed applications require lots of hidden files that aren’t always relevant to everyday users. But there will be cases where, as a programmer, you’ll want to view them.
Flag, which is an additional command argument that modifies the behavior of the base command.
Flags start with the - prefix.
Type ls -a, which is the list command followed by the -a flag. This means, “Show me all of the files in my working directory and do not ignore entries that start with a period.”

return to our parent directory. To do so, we use the cd command followed by a space and two dots:
cd ..
The dots imply “parent directory.”
Now, if we type pwd, we’ll see that we’re in our home directory, which may look like /Users/yourname if you’re on a Mac.

mkdir nameoffolder :make new folder

If we were deeper in our file structure, we could use the cd ~ command.
The tilde (~) is a shortcut for the home directory of the terminal’s current user.

we’ll create a new file.
Say we want to make HTML and CSS files — the beginnings of a website!
To accomplish this, we’ll use the touch command. We can even make multiple files and file types at the same time by separating them with a space, like this:
touch index.html style.css

Removing Files
Be careful when using rm. Unlike moving files to the trash or recycle bin, deleting files with rm removes them permanently!

To remove directories as well. 
Type rm -r myfolder to remove the myfolder directory.
-r:It stands for recursive and states that we will remove the directory along with any subdirectories or child directories. It is impossible to have a child directory without a parent directory, therefore the -r flag is always required when removing directories.
Another option, assuming the directory is empty, is rmdir, which is functionally equivalent to rm -r when executed against an empty directory.

Initializing:
$ git init
To take advantage of Git superpowers, we have to add a hidden directory called .git/ to our project directory, which contains all of the data Git needs to operate.

git status: which asks Git to give us an update on our project’s status.

To add change to your next commit, you'll use the git add command.
$ git add my-first-post.txt
The command is add, but we describe the operation by saying that the file has been “staged.” In other words, it has been added to the list of changes that will be officially saved with our next commit.
The files on this list aren’t final, and any of these changes can be removed, or “unstaged.”

add all of the files in the working directory to the next commit:
Instead of specifying each file, you can write git add .
Proceed with caution when using git add ., as you could accidentally add files with sensitive information.

To officially record this version of our project, type:
$ git commit -m "created a new post.txt file"
The -m option allows you to include a message that describes the changes you made for your collaborators or future you.
These should be short but descriptive and clearly indicate what changes each commit makes to the project.

working area->staging->local repo

Git allows you to add changes to your project in the local repository with two steps:
$ git add <your-file-name>
$ git commit -m "message"

SHA: it allows developers to view a list of commits, the submission date, the author, the commit message, and a unique number that identifies the commit

To view the timeline of changes, you can run:
$ git log
This will yield a list of entries that looks like this:

personal:
git init
git config user.name "someone"                  (add -global to do for account)
git config user.email "someone@someplace.com".  (add -global to do for account)

Before running git init, make sure you’re not already inside another Git repository. 
Type git status. 
If you see fatal: Not a git repository (or any of the parent directories): .git, then you know you’re good to go and you can safely run git init within this folder.

To save the changes that we’ve made to our work to the GitHub platform, we must:
-Stage all of the files using git add.
-Commit our changes using git commit -m “message”.
-Push the committed changes up to GitHub using git push.
